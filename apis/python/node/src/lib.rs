#![allow(clippy::borrow_deref_ref)] // clippy warns about code generated by #[pymethods]

use std::ops::Deref;

use dora_node_api::{
    daemon::{Event, EventStream},
    dora_core::config::NodeId,
    DoraNode,
};
use dora_operator_api_python::{metadata_to_pydict, pydict_to_metadata};
use eyre::{Context, Result};
use pyo3::{
    prelude::*,
    types::{PyBytes, PyDict},
};

#[pyclass]
pub struct Node {
    id: NodeId,
    events: EventStream,
    node: DoraNode,
}

pub struct PyInput<'a>(Event<'a>);

impl IntoPy<PyObject> for PyInput<'_> {
    fn into_py(self, py: Python) -> PyObject {
        match self.0 {
            Event::Stop => ("stop").into_py(py),
            Event::Input { id, metadata, data } => (
                "input",
                id.to_string(),
                PyBytes::new(py, data.as_deref().unwrap_or_default()),
                metadata_to_pydict(&metadata, py),
            )
                .into_py(py),
            Event::InputClosed { id } => ("input-closed", id.deref()).into_py(py),
            Event::Error(err) => ("error", err).into_py(py),
            other => ("unknown", format!("{other:?}")).into_py(py),
        }
    }
}

#[pymethods]
impl Node {
    #[new]
    pub fn new() -> Result<Self> {
        let id = {
            let raw =
                std::env::var("DORA_NODE_ID").wrap_err("env variable DORA_NODE_ID must be set")?;
            serde_yaml::from_str(&raw).context("failed to deserialize operator config")?
        };

        let (node, events) = DoraNode::init_from_env()?;

        Ok(Node { id, events, node })
    }

    #[allow(clippy::should_implement_trait)]
    pub fn next(&mut self) -> PyResult<Option<PyInput>> {
        self.__next__()
    }

    pub fn __next__(&mut self) -> PyResult<Option<PyInput>> {
        Ok(self.events.recv().map(PyInput))
    }

    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
        slf
    }

    pub fn send_output(
        &mut self,
        output_id: String,
        data: &PyBytes,
        metadata: Option<&PyDict>,
    ) -> Result<()> {
        let data = data.as_bytes();
        let metadata = pydict_to_metadata(metadata)?;
        self.node
            .send_output(output_id.into(), metadata, data.len(), |out| {
                out.copy_from_slice(data);
            })
            .wrap_err("Could not send output")
    }

    pub fn id(&self) -> String {
        self.id.to_string()
    }
}

// #[pyfunction]
// fn start_runtime() -> Result<()> {
//     dora_runtime::main()
//         .wrap_err("Python Dora Runtime failed.")
//         .unwrap();
//     Ok(())
// }

// #[pymodule]
// fn dora(_py: Python, m: &PyModule) -> PyResult<()> {
//     m.add_function(wrap_pyfunction!(start_runtime, m)?)?;
//     m.add_class::<Node>().unwrap();
//     Ok(())
// }
