#![allow(clippy::borrow_deref_ref)] // clippy warns about code generated by #[pymethods]

use arrow::pyarrow::PyArrowConvert;
use dora_node_api::{DoraNode, Event, EventStream};
use dora_operator_api_python::{metadata_to_pydict, pydict_to_metadata};
use eyre::{Context, Result};
use pyo3::prelude::*;
use pyo3::types::PyDict;
#[pyclass]
pub struct Node {
    events: EventStream,
    node: DoraNode,
}

pub struct PyInput(Event);

impl IntoPy<PyObject> for PyInput {
    fn into_py(self, py: Python) -> PyObject {
        let dict = PyDict::new(py);

        let ty = match self.0 {
            Event::Stop => "STOP",
            Event::Input { id, metadata, data } => {
                dict.set_item("id", id.to_string())
                    .wrap_err("failed to add input ID")
                    .unwrap();
                if let Some(data) = data {
                    let array = data.into_arrow_array();
                    // TODO: Does this call leak data?
                    let array_data = array
                        .to_pyarrow(py)
                        .wrap_err("failed to convert arrow data to Python")
                        .unwrap();
                    dict.set_item("data", array_data)
                        .wrap_err("failed to add input data")
                        .unwrap();
                }

                dict.set_item("metadata", metadata_to_pydict(&metadata, py))
                    .wrap_err("failed to add input metadata")
                    .unwrap();
                "INPUT"
            }
            Event::InputClosed { id } => {
                dict.set_item("id", id.to_string())
                    .wrap_err("failed to add closed-input ID")
                    .unwrap();
                "INPUT_CLOSED"
            }
            Event::Error(err) => {
                dict.set_item("error", err)
                    .wrap_err("failed to add error")
                    .unwrap();
                "ERROR"
            }
            _other => "UNKNOWN",
        };

        dict.set_item("type", ty)
            .wrap_err("could not make type a python dictionary item")
            .unwrap();

        dict.into()
    }
}

#[pymethods]
impl Node {
    #[new]
    pub fn new() -> Result<Self> {
        let (node, events) = DoraNode::init_from_env()?;

        Ok(Node { events, node })
    }

    #[allow(clippy::should_implement_trait)]
    pub fn next(&mut self) -> PyResult<Option<PyInput>> {
        self.__next__()
    }

    pub fn __next__(&mut self) -> PyResult<Option<PyInput>> {
        Ok(self.events.recv().map(PyInput))
    }

    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
        slf
    }

    pub fn send_output(
        &mut self,
        output_id: String,
        data: PyObject,
        metadata: Option<&PyDict>,
        py: Python,
    ) -> Result<()> {
        let data = arrow::array::ArrayData::from_pyarrow(data.as_ref(py))
            .wrap_err("failed to read data as Arrow array")?;
        if data.buffers().len() != 1 {
            eyre::bail!("output arrow array must contain a single buffer");
        }

        let len = data.len();
        let slice = &data.buffer(0)[..len];

        let metadata = pydict_to_metadata(metadata)?;
        self.node
            .send_output(output_id.into(), metadata, len, |out| {
                out.copy_from_slice(slice);
            })
            .wrap_err("Could not send output")
    }

    pub fn id(&self) -> String {
        self.node.id().to_string()
    }
}

#[pyfunction]
fn start_runtime() -> Result<()> {
    dora_runtime::main().wrap_err("Dora Runtime raised an error.")
}

#[pymodule]
fn dora(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(start_runtime, m)?)?;
    m.add_class::<Node>().unwrap();
    Ok(())
}
