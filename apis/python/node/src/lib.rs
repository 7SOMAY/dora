#![allow(clippy::borrow_deref_ref)] // clippy warns about code generated by #[pymethods]

use dora_node_api::{DoraNode, Event, EventStream};
use dora_operator_api_python::{metadata_to_pydict, pydict_to_metadata};
use eyre::{Context, Result};
use pyo3::{
    prelude::*,
    types::{PyBytes, PyDict},
};

#[pyclass]
pub struct Node {
    events: EventStream,
    node: DoraNode,
}

pub struct PyInput<'a>(Event<'a>);

impl IntoPy<PyObject> for PyInput<'_> {
    fn into_py(self, py: Python) -> PyObject {
        let dict = PyDict::new(py);

        let ty = match self.0 {
            Event::Stop => "STOP",
            Event::Input { id, metadata, data } => {
                dict.set_item("id", id.to_string())
                    .wrap_err("failed to add input ID")
                    .unwrap();
                dict.set_item(
                    "data",
                    PyBytes::new(py, data.as_deref().unwrap_or_default()),
                )
                .wrap_err("failed to add input data")
                .unwrap();
                dict.set_item("metadata", metadata_to_pydict(&metadata, py))
                    .wrap_err("failed to add input metadata")
                    .unwrap();
                "INPUT"
            }
            Event::InputClosed { id } => {
                dict.set_item("id", id.to_string())
                    .wrap_err("failed to add closed-input ID")
                    .unwrap();
                "INPUT_CLOSED"
            }
            Event::Error(err) => {
                dict.set_item("error", err)
                    .wrap_err("failed to add error")
                    .unwrap();
                "ERROR"
            }
            _other => "UNKNOWN",
        };

        dict.set_item("type", ty)
            .wrap_err("could not make type a python dictionary item")
            .unwrap();

        dict.into()
    }
}

#[pymethods]
impl Node {
    #[new]
    pub fn new() -> Result<Self> {
        let (node, events) = DoraNode::init_from_env()?;

        Ok(Node { events, node })
    }

    #[allow(clippy::should_implement_trait)]
    pub fn next(&mut self) -> PyResult<Option<PyInput>> {
        self.__next__()
    }

    pub fn __next__(&mut self) -> PyResult<Option<PyInput>> {
        Ok(self.events.recv().map(PyInput))
    }

    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
        slf
    }

    pub fn send_output(
        &mut self,
        output_id: String,
        data: &PyBytes,
        metadata: Option<&PyDict>,
    ) -> Result<()> {
        let data = data.as_bytes();
        let metadata = pydict_to_metadata(metadata)?;
        self.node
            .send_output(output_id.into(), metadata, data.len(), |out| {
                out.copy_from_slice(data);
            })
            .wrap_err("Could not send output")
    }

    pub fn id(&self) -> String {
        self.node.id().to_string()
    }
}

#[pyfunction]
fn start_runtime() -> Result<()> {
    dora_runtime::main().wrap_err("Python Dora Runtime failed.")
}

#[pymodule]
fn dora(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(start_runtime, m)?)?;
    m.add_class::<Node>().unwrap();
    Ok(())
}
